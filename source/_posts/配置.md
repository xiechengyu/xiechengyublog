## 配置

```json
{
  AAAA:{
    error:12345,
    message:"呀呀呀呀呀呀"
  },
  BBBB:{
    error:10001,
    message:"qqqqq"
  }
}
```





​           

## api:

#### throw:

code：对应的code 比如 SYSTEM_EXCEPTION



ctx.kcThrowError(code) 



#### response:

code：响应对应的code

params：改写原配置

log:是否上传到日志,调试时使用

fn:改写默认方法



ctx.kcResponseError(code,params,log,fn)//逻辑就会停止、执行对应逻辑、打印和上传错误日志



ctx.kcResponseWarn(code,params,log,fn) //逻辑不停止、执行对应逻辑、打印和上传警告日志



## 场景

```js
async getUser(){
 	 try{
  	await getName()
	}catch(e){
  	ctx.kcResponseError(code,params,log)
	}
}

getName(){
  if(...){
      ctx.kcThrowError(code)
   }
}
```



```js
try {
    localStorage.setItem(key, data);
} catch (e) {
    if (e.code === QUOTA_EXCEEDED_ERR_CODE) {
        localStorage.clear();
        localStorage.setItem(key, data);
        ctx.kcResponseWarn(code,params,log)
    }
}
```







是否直接使用egg-onerror在框架里保底

 







# 基于egg-bizerror

整体基本满足：

1、可以满足业务层面的异常处理，通过配置errorcode的throwBizError()和responseBizError()，没有被配置的errorcode会当做系统异常。   trycatch 后需要多用responseBizError，因为会被拦截。

2、非业务性的异常用egg-onerror配置，可直接在插件中配置默认，在项目中重新设置可覆盖



增加一些功能

1、警告级别可继续执行逻辑

2、日志相关：自定义？上传？切割？

